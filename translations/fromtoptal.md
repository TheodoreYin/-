# 好代码六戒：写出经得起时间考验的代码(上)

人们已经纠缠编程的艺术和科学几乎半个世纪了。比起大部分艺术和科学，计算机科学可以说还蹒跚学步的小孩。就其尚属年青的阶段而言，我不相信我们已经恰当定义了”好代码“——它尚需完善。一些人会说100%测试覆盖的代码是”好代码“，另一些认为它应该是超级高速，拥有杀手级表现(killer performance)并能在10年前的硬件上完美运行。这些目标确实都值得开发者们称道，但我冒昧道出另一个目标：可维护性(maintainability)。具体说，”好代码“应该易于并准备好被团队（而不仅仅是其作者）维护，并能长时间存在。以下是一些我在米国和国外的大小公司工作中发现的可能与可维护的”好“软件有关的东西。

## 戒律1：写代码时将心比心

我不是第一个写过这件事的人：你的代码的主要受众不是编译器/电脑，而是第一个必须阅读、理解、维护和掌握它的人（而这很可能在6个月后）。任何配得上他们薪水的程序员都能写出”能跑“的代码，但真正区分出卓越的工程师的是他们能高效地写出可维护的代码，以长期支撑产品的运作，并能以清晰、可维护的方式解决问题。

用任何语言都能写出好代码和烂代码，但假设我们以能否促成(facilitates)好代码（至少满足一个最高标准）来评价一门语言，任何语言的好坏都取决于怎样使用（或滥用）他们。

 一个被许多人认为是编程语言中”清晰“易读的例子是Python。这门语言自身就强制某种级别的缩进和换行纪律，它的内建API亦丰富且相当一致。这就是说，用它有可能创造出沉默的怪物。举个例子，某人可能定义一个类，并在运行时定义/重定义/不定义任何方法(这经常被称为monkey patching)。这一技术自然地最终催生出一个不一致的API，一个最后无法Debug的怪兽。有人可能naive的认为”是啊，但没人会这么做！“很不幸的是他们确实会这么干。如果你花一点时间看看[pypi](https://pypi.python.org/pypi) ，你会发现大量（受欢迎的）的库普遍地(滥)用monkey patching的方式编写它们API的核。我最近用了一个网络库，它的整个API取决于一个对象的网络状态。想象一下，假如调用`client.connect()`有时竟会得到一个`MethodDoesNotExist`错误而非`HostNotFound`或者`NetworkUnavaliable`。

## 戒律2：好代码不管部分还是整体都易于理解

好代码是易于他人（同样包括未来的作者自己，试着避免“我真的写过这个？”综合征）阅读和理解的，不管是部分还是整体。

“部分”是指如果我打开代码中的某个模块或函数，我应该能理解它到底是干嘛的，而不用去读整个代码库的其他部分。代码应该尽可能的直观和自解释(self-documenting)。

不断引用代码库中影响其他部分(似乎不相关的部分)行为的细微代码(Code that constantly references minute details that affect behavior from other (seemingly irrelevant) portions of the codebase)就像在读一本你需要在每一句话后面查看引用的脚注和附录的书一样——你永远没法读完第一页！

一些其他的关于“接地气的(local)”可阅读性的想法：

* 良好[封装](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))的代码更加易读，在每个层级进行[关注分离](https://en.wikipedia.org/wiki/Separation_of_concerns)。

* **名字很重要**。[Thinking Fast and Slow(一本书)](https://www.amazon.com/Thinking-Fast-Slow-Daniel-Kahneman/dp/0374533555)显示名字使人脑建立想法，它使一些实际的、谨慎的想法赋予变量和方法的名字中。这额外的几秒能带来巨大的好处。一个良好命名的变量能使得代码更加直观，相应的命名捉急的变量能导致误判(headfakes)和困惑.

* **小聪明是敌人**。当使用流行的技术，范例和方法(像列表推导和三元运算符)，小心使用来使你的代码更易读，而不是仅仅使它变短了。

* **一致性是好东西**。在样式上的一致性，无论是如何放置括号，还是在操作方面，都大大提高了可读性。
* **[关注分离](https://en.wikipedia.org/wiki/Separation_of_concerns)**。一个给定的项目在众多节点管理着难以计数的重要本地假设。尽可能少地将他们暴露出来。假如你有一个人员管理系统，一个人员类有时会得到null的姓，对那些负责写展示人员类页面的人来说那将是多么尴尬呀！如果你没有一本名叫“我们代码库中不明显的本地假设及他们造成的尴尬”的手册(我知道你没有)，你的展示页面工程师不可能知道姓氏可以是null，并可能在这一情况出现时写出空指针异常的代码。编写经过完善考虑的API，与负责其他部分的同事拟定协议标准，来避免这些情况。


## 戒律3：好的代码通过深思熟虑的布局和架构，使管理状态变得清晰

状态是敌人。为什么？因为他是所有应用中最复杂的部分，需要被小心谨慎地处理。常见的问题包括数据库前后矛盾，部分界面更新，而其中的新数据不在任何地方出现，无序的操作，或者只是令人头皮发麻的，到处都是if语句和分支的代码难以被维护。将状态放在显要位置，小心处理，对于如何访问和修改状态极为一致和谨慎，尽量简化代码库。一些语言（例如Haskell）在程序和句法层面上强制执行这些。如果你有不访问外部状态的[纯函数](https://en.wikipedia.org/wiki/Pure_function)库，的那么你会惊讶于你代码库的清晰度的改善。



